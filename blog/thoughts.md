# Simpatico - off the rails?

I've not been working on Simpatico for a while, although it's been on my mind. It's a hard truth to swallow, but I think I've gone too far in a direction that sort of misses the point. Two things, actually: first, splitting the website off of the simpatico server itself, and making simpatico an executable tool. Second, extending the server itself to support virtual hosts. It's important to remember what I was moving away from, which is a completely self-contained project whose distribution required `git clone` and which supported a single website under a single domain.  

The funny thing is that all of this webserver stuff is a *distraction* from what the main purpose of the Simpatico server was supposed to be: the smallest possible thing that works to connect browsers to each other. Many of the features of that server (e.g. caching, literate markdown) are just unintended side-effects of me wanting a fast, no-build server that supports a fast BTD loop and no supporting processes (e.g. tls termination in nginx).

I then had the idea to extend Simpatico further to be an ad hoc server you could run at the command line to serve whatever is in the current directory. In an effort to "eat my own dogfood" I split out the simpatico.io website from simpatico itself and have been running it that way. I'm unhappy with that implementation in a few ways:

  1. It's more complication to support a mode that doesn't make sense. Simpatico as a server is more of a classic httpd, nginx, caddy type of thing that expects a single process to be running system-wide. So it doesn't make sense to invoke simpatico more than once on a system, but rather it makes sense to do what other servers do and have a stable, central configuration that points to different parts of the file-system.
  2. Splitting the website and the server creates complication with how resources are loaded. Since simpatico is not purely a server and supplies lots of libraries for both the front and back end, I've had to think through this for both p/npm and the browser. I'm glad it works, but I don't think the juice is worth the squeeze. Furthermore my solution has caused problems with logging (really long filenames) that are non-trivial to solve.

So it's a decision point. Either I continue putting effort into making Simpatico a general HTTP server to compete with nginx/caddy/httpd/etc or I pull back from that and focus on what makes it special. I like the original goals of the project to be a really simple single process single domain server that runs in "immediate mode" from it's repo. It's a great mental model and it makes the code simple. Although I'm loathe to give up the fruit of the effort I put into binding to port 80 with suid, and TLS certs with Let's Encrypt support and live no downtime cert updates, I never entirely removed the ability to run on different ports or work on a simple HTTP connection. Which means that if I want to host multiple domains on a single VPS I can use nginx with a reverse proxy back to simpatico, which honestly takes a LOT of pressure off of Simpatico. I'd like to continue to support TLS termination, caching, and so on, but I may not actually use it in production, which is fine.

The #1 goal remains to provide a bootstrap for secure, private websocket connection between connected browsers. The convenience of litmd is nice but secondary. The pull toward a full-featured server is a dangerous red-herring and should be resisted.

## What now?
Okay, so I'd like to keep this work around on a branch, at least, and or a tag. I *like* the idea of using simpatico as an ad hoc markdown aware server - I can see it useful for people who want to, for example, serve their Obsidian notes as an actual website. But that's really a very different use-case and may even be a different project.

So Simpatico will have two modes: monolithic mode, where Simpatico runs a single TLS terminating process capable of safely binding https to port 80. It will also support secondary mode, where it binds http to port 8080, for example, and it's expected that you'll run a reverse proxy in production. Interestingly, some browser functions are not available unless you're running over https (although some browsers relax this requirement if served as localhost), so monolithic mode will continue to be the default mode, even for running a local development version.

